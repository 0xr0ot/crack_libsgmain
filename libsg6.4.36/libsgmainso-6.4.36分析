libsgmainso-6.4.36分析

//////////////////////////////////////////////////////////////

難點：

動態跳轉
動態生成參數，參數變形
函數隱藏（需要通過一個類似的裝跳過去），或者說函數前面有一段垃圾代碼吧
字符串加密
部分關鍵代碼存在llvm混淆
垃圾代碼，靜態分析對抗，擾亂ida分析
多種加密算法



LOAD:0000B110 JNI_OnLoad
LOAD:0000B110
LOAD:0000B110 var_4           = -4
LOAD:0000B110 07 B5          PUSH            {R0-R2,LR}
LOAD:0000B112 07 A1          ADR             R1, 0xB130 // B130
LOAD:0000B114 09 00          MOVS            R1, R1
LOAD:0000B116 05 39          SUBS            R1, #5 // B130 - 0X5 = B12B
LOAD:0000B118 00 00          MOVS            R0, R0
LOAD:0000B11A 08 00          MOVS            R0, R1 // B12B
LOAD:0000B11C 12 00          MOVS            R2, R2
LOAD:0000B11E 10 30          ADDS            R0, #0x10 // B12B + 0X10 = B13B
LOAD:0000B120 03 90          STR             R0, [SP,#0xC] // SP + 0XC = R0 = B13B
LOAD:0000B122 07 BD          POP             {R0-R2,PC} // PC = sp + 0xc = B13B, thumb指令跳转到0000B13A 

执行完上述代码，r0,r1,r2,lr值不变，变的仅仅是pc，cpu会马上执行pc处的指令

=================================================================================================
代码段共56处匹配这样的特征，想办法patch这样的逻辑
patch 后
LOAD:0000B110 JNI_OnLoad
LOAD:0000B122                 B               loc_B13A
===================================================================================================

因为是thumb指令，地址起始奇数
LOAD:0000B13A ; ---------------------------------------------------------------------------
特徵
LOAD:0000B13A                 CODE16
LOAD:0000B13A                 PUSH            {R0,R1,LR}
LOAD:0000B13C                 LDR             R0, =8
LOAD:0000B13E                 LDR             R1, loc_B140 // 沒有意義， nop掉
LOAD:0000B140
LOAD:0000B140 loc_B140     
LOAD:0000B140                 BLX             sub_494C    /// 分发器
LOAD:0000B140 ; ---------------------------------------------------------------------------
LOAD:0000B144 dword_B144      DCD 8            
-------------------------------------------------------------------------------------------
跳轉表，共40個跳轉， 計算pc時的纍加值：               
LOAD:0000B144                                            
LOAD:0000B144                                            ;第一個index = 8
LOAD:0000B144                                            ; 找到8對應的偏移，它下一個index即下一個邏輯
LOAD:0000B148 A8 00 00 00                 DCD 0xA8       ; b1ec
LOAD:0000B14C BC 00 00 00                 DCD 0xBC       ; b200
LOAD:0000B150 CC 00 00 00                 DCD 0xCC       ; b120
LOAD:0000B154 E0 00 00 00                 DCD 0xE0       ; b224
LOAD:0000B158 F0 00 00 00                 DCD 0xF0       ; b234
LOAD:0000B15C 00 01 00 00                 DCD 0x100      ; b244
LOAD:0000B160 10 01 00 00                 DCD 0x110      ; b254
LOAD:0000B164 20 01 00 00                 DCD 0x120      ; b264 偏移為8，表值為0x120，第一個對應lr + off = b144 + 0x120
LOAD:0000B168 34 01 00 00                 DCD 0x134      ; b278
LOAD:0000B16C 4C 01 00 00                 DCD 0x14C      ; b290
LOAD:0000B170 68 01 00 00                 DCD 0x168      ; b2ac
LOAD:0000B174 7C 01 00 00                 DCD 0x17C      ; b2c0
LOAD:0000B178 94 01 00 00                 DCD 0x194      ; b2d8
LOAD:0000B17C AC 01 00 00                 DCD 0x1AC      ; b2f0
LOAD:0000B180 D4 01 00 00                 DCD 0x1D4      ; b318
LOAD:0000B184 EC 01 00 00                 DCD 0x1EC      ; b330
LOAD:0000B188 08 02 00 00                 DCD 0x208      ; b34c
LOAD:0000B18C 24 02 00 00                 DCD 0x224      ; b368
LOAD:0000B190 40 02 00 00                 DCD 0x240      ; b384
LOAD:0000B194 68 02 00 00                 DCD 0x268      ; b3ac
LOAD:0000B198 7C 02 00 00                 DCD 0x27C      ; b3c0
LOAD:0000B19C 90 02 00 00                 DCD 0x290      ; b3d4
LOAD:0000B1A0 A4 02 00 00                 DCD 0x2A4      ; b3e0
LOAD:0000B1A4 B8 02 00 00                 DCD 0x2B8      ; b3fc
LOAD:0000B1A8 CC 02 00 00                 DCD 0x2CC      ; b410
LOAD:0000B1AC E0 02 00 00                 DCD 0x2E0      ; b424
LOAD:0000B1B0 FC 02 00 00                 DCD 0x2FC      ; b440
LOAD:0000B1B4 10 03 00 00                 DCD 0x310      ; b454
LOAD:0000B1B8 24 03 00 00                 DCD 0x324      ; b468
LOAD:0000B1BC 3C 03 00 00                 DCD 0x33C      ; b480
LOAD:0000B1C0 58 03 00 00                 DCD 0x358      ; b49c
LOAD:0000B1C4 6C 03 00 00                 DCD 0x36C      ; b4b0
LOAD:0000B1C8 90 03 00 00                 DCD 0x390      ; b4d4
LOAD:0000B1CC AC 03 00 00                 DCD 0x3AC      ; b4f0
LOAD:0000B1D0 C4 03 00 00                 DCD 0x3C4      ; b508
LOAD:0000B1D4 D8 03 00 00                 DCD 0x3D8      ; b51c
LOAD:0000B1D8 F0 03 00 00                 DCD 0x3F0      ; b534
LOAD:0000B1DC 14 04 00 00                 DCD 0x414      ; b558
LOAD:0000B1E0 28 04 00 00                 DCD 0x428      ; b56c
LOAD:0000B1E4 40 04 00 00                 DCD 0x440      ; b584
LOAD:0000B1E8 5C 04 00 00                 DCD 0x45C      ; b5a0
-------------------------------------------------------------------------------------------------------------
以第一次跳轉為例：
LOAD:0000494C sub_494C                              
LOAD:0000494C arg_8           =  8
LOAD:0000494C                 BIC             R1, LR, #1  // LR = B144 , 最低一位清零  R1 还是B144
//LOAD:0000B164    DCD 0x120
LOAD:00004950 00 11 91 E7     LDR  R1, [R1,R0,LSL#2] 	  // R1 = [B144 + 0x8 << 2] =  [B144 + 0X20] = [B164] = 0x120
LOAD:00004954                 ADD             R1, R1, LR  // R1 = B144 + 0x120 = B264
LOAD:00004958                 LDR             LR, [SP,#8] // LR = B144
LOAD:0000495C                 STR             R1, [SP,#8] // B264
LOAD:00004960 03 80 BD E8     LDMFD           SP!, {R0,R1,PC} // R0 = [SP], R1 = [SP + 4], PC = [SP + 8] 跳转到B264
隨便列舉幾個跳轉：
1 = 0xb264
2 = 0x1511c
3 = 0x24764
4 = 0x5f2ac
5 = 0x71e70
6 = 0x72dbc
7 = 0x9a14
...
---------------------------------------------------------------------------------------------
其他混淆跳轉輔助指令特徵：
LOAD:0000494C
LOAD:0000494C             ; =============== S U B R O U T I N E =======================================
LOAD:0000494C
LOAD:0000494C
LOAD:0000494C             dyna_pc                                 ; CODE XREF: j_dyna_pcj
LOAD:0000494C                                                     ; LOAD:loc_4C20p ...
LOAD:0000494C
LOAD:0000494C             arg_8           =  8
LOAD:0000494C
LOAD:0000494C 01 10 CE E3                 BIC             R1, LR, #1
LOAD:00004950 00 11 91 E7                 LDR             R1, [R1,R0,LSL#2] ; lr(最低位清零) + (r0 << 2)
LOAD:00004954 0E 10 81 E0                 ADD             R1, R1, LR
LOAD:00004958 08 E0 9D E5                 LDR             LR, [SP,#8]
LOAD:0000495C 08 10 8D E5                 STR             R1, [SP,#8]
LOAD:00004960 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC} ; 1 = 0xb264
LOAD:00004960             ; End of function dyna_pc               ; 2 = 0x1511c
LOAD:00004960                                                     ; 3 = 0x24764
LOAD:00004960                                                     ; 4 = 0x5f2ac
LOAD:00004960                                                     ; 5 = 0x71e70
LOAD:00004960                                                     ; 6 = 0x72dbc
LOAD:00004960                                                     ; 7 = 0x9a14
LOAD:00004960                                                     ; ...
LOAD:00004964
LOAD:00004964             ; =============== S U B R O U T I N E =======================================
LOAD:00004964
LOAD:00004964             ; 完成pc = pc + 8
LOAD:00004964             ; 待彈出寄存器值為 lr + [lr]
LOAD:00004964             ; 目的是完成動態生成函數參數
LOAD:00004964
LOAD:00004964             dyna_mkarg                              ; CODE XREF: sub_4ADC:loc_4AE0j
LOAD:00004964                                                     ; LOAD:00004D16p ...
LOAD:00004964
LOAD:00004964             anonymous_0     =  0
LOAD:00004964             arg_C           =  0xC
LOAD:00004964             arg_10          =  0x10
LOAD:00004964
LOAD:00004964 01 00 CE E3                 BIC             R0, LR, #1
LOAD:00004968 00 10 90 E5                 LDR             R1, [R0]
LOAD:0000496C 01 10 90 E7                 LDR             R1, [R0,R1]
LOAD:00004970 04 E0 8E E2                 ADD             LR, LR, #4
LOAD:00004974 0C E0 8D E5                 STR             LR, [SP,#0xC] ; pc = lr + 4 ,下一條指令処
LOAD:00004978 10 10 8D E5                 STR             R1, [SP,#0x10] ; 後面pop 寄存器的值
LOAD:0000497C 03 C0 BD E8                 LDMFD           SP!, {R0,R1,LR,PC} ; pc =  pc + 8
LOAD:0000497C
LOAD:00004980
LOAD:00004980             ; =============== S U B R O U T I N E =======================================
LOAD:00004980
LOAD:00004980
LOAD:00004980             sub_4980                                ; CODE XREF: sub_4ABC:loc_4AC0j
LOAD:00004980
LOAD:00004980             arg_8           =  8
LOAD:00004980
LOAD:00004980 01 10 CE E3                 BIC             R1, LR, #1
LOAD:00004984 00 11 91 E7                 LDR             R1, [R1,R0,LSL#2]
LOAD:00004988 81 00 8E E0                 ADD             R0, LR, R1,LSL#1
LOAD:0000498C 08 E0 9D E5                 LDR             LR, [SP,#arg_8]
LOAD:00004990 08 00 8D E5                 STR             R0, [SP,#arg_8]
LOAD:00004994 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC}
LOAD:00004994             ; End of function sub_4980
LOAD:00004994
LOAD:00004998
LOAD:00004998             ; =============== S U B R O U T I N E =======================================
LOAD:00004998
LOAD:00004998
LOAD:00004998             sub_4998                                ; CODE XREF: sub_4AC4:loc_4AC8j
LOAD:00004998                                                     ; LOAD:000098FCp ...
LOAD:00004998
LOAD:00004998             arg_8           =  8
LOAD:00004998
LOAD:00004998 01 00 CE E3                 BIC             R0, LR, #1
LOAD:0000499C 00 10 90 E5                 LDR             R1, [R0]
LOAD:000049A0 0E 10 81 E0                 ADD             R1, R1, LR
LOAD:000049A4 08 E0 9D E5                 LDR             LR, [SP,#arg_8]
LOAD:000049A8 08 10 8D E5                 STR             R1, [SP,#arg_8]
LOAD:000049AC 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC}
LOAD:000049AC             ; End of function sub_4998
LOAD:000049AC
LOAD:000049B0
LOAD:000049B0             ; =============== S U B R O U T I N E =======================================
LOAD:000049B0
LOAD:000049B0
LOAD:000049B0             sub_49B0
LOAD:000049B0
LOAD:000049B0             arg_C           =  0xC
LOAD:000049B0             arg_10          =  0x10
LOAD:000049B0
LOAD:000049B0 01 00 CE E3                 BIC             R0, LR, #1
LOAD:000049B4 00 10 90 E5                 LDR             R1, [R0]
LOAD:000049B8 00 10 81 E0                 ADD             R1, R1, R0
LOAD:000049BC 04 E0 8E E2                 ADD             LR, LR, #4
LOAD:000049C0 0C E0 8D E5                 STR             LR, [SP,#arg_C]
LOAD:000049C4 10 10 8D E5                 STR             R1, [SP,#arg_10]
LOAD:000049C8 03 C0 BD E8                 LDMFD           SP!, {R0,R1,LR,PC}
LOAD:000049C8             ; End of function sub_49B0
LOAD:000049C8
LOAD:000049CC
LOAD:000049CC             ; =============== S U B R O U T I N E =======================================
LOAD:000049CC
LOAD:000049CC
LOAD:000049CC             sub_49CC
LOAD:000049CC
LOAD:000049CC             var_4           = -4
LOAD:000049CC
LOAD:000049CC 03 40 2D E9                 STMFD           SP!, {R0,R1,LR}
LOAD:000049D0 0E 10 A0 E1                 MOV             R1, LR
LOAD:000049D4 A1 10 A0 E1                 MOV             R1, R1,LSR#1
LOAD:000049D8 81 10 A0 E1                 MOV             R1, R1,LSL#1
LOAD:000049DC 01 00 A0 E1                 MOV             R0, R1
LOAD:000049E0 00 10 91 E5                 LDR             R1, [R1]
LOAD:000049E4 00 10 81 E0                 ADD             R1, R1, R0
LOAD:000049E8 00 10 91 E5                 LDR             R1, [R1]
LOAD:000049EC 08 10 8D E5                 STR             R1, [SP,#0xC+var_4]
LOAD:000049F0 04 E0 8E E2                 ADD             LR, LR, #4
LOAD:000049F4 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC}
LOAD:000049F4             ; End of function sub_49CC
LOAD:000049F4
LOAD:000049F8
LOAD:000049F8             ; =============== S U B R O U T I N E =======================================
LOAD:000049F8
LOAD:000049F8
LOAD:000049F8             sub_49F8
LOAD:000049F8
LOAD:000049F8             arg_4           =  4
LOAD:000049F8
LOAD:000049F8 04 E0 9D E5                 LDR             LR, [SP,#arg_4]
LOAD:000049FC 04 00 8D E5                 STR             R0, [SP,#arg_4]
LOAD:00004A00 01 80 BD E8                 LDMFD           SP!, {R0,PC}
LOAD:00004A00             ; End of function sub_49F8
LOAD:00004A00
LOAD:00004A04
LOAD:00004A04             ; =============== S U B R O U T I N E =======================================
LOAD:00004A04
LOAD:00004A04
LOAD:00004A04             sub_4A04
LOAD:00004A04
LOAD:00004A04             arg_C           =  0xC
LOAD:00004A04             arg_10          =  0x10
LOAD:00004A04             arg_14          =  0x14
LOAD:00004A04
LOAD:00004A04 0E 10 A0 E1                 MOV             R1, LR
LOAD:00004A08 A1 10 A0 E1                 MOV             R1, R1,LSR#1
LOAD:00004A0C 81 10 A0 E1                 MOV             R1, R1,LSL#1
LOAD:00004A10 01 00 A0 E1                 MOV             R0, R1
LOAD:00004A14 00 10 91 E5                 LDR             R1, [R1]
LOAD:00004A18 00 10 81 E0                 ADD             R1, R1, R0
LOAD:00004A1C 00 00 91 E5                 LDR             R0, [R1]
LOAD:00004A20 04 10 91 E5                 LDR             R1, [R1,#4]
LOAD:00004A24 10 00 8D E5                 STR             R0, [SP,#arg_10]
LOAD:00004A28 14 10 8D E5                 STR             R1, [SP,#arg_14]
LOAD:00004A2C 04 E0 8E E2                 ADD             LR, LR, #4
LOAD:00004A30 0C E0 8D E5                 STR             LR, [SP,#arg_C]
LOAD:00004A34 03 40 BD E8                 LDMFD           SP!, {R0,R1,LR}
LOAD:00004A38 04 F0 9D E4                 LDR             PC, [SP-0xC+arg_C],#4
LOAD:00004A38             ; End of function sub_4A04
LOAD:00004A38
LOAD:00004A3C
LOAD:00004A3C             ; =============== S U B R O U T I N E =======================================
LOAD:00004A3C
LOAD:00004A3C
LOAD:00004A3C             sub_4A3C                                ; CODE XREF: sub_4AE4:loc_4AE8j
LOAD:00004A3C
LOAD:00004A3C             var_8           = -8
LOAD:00004A3C             var_4           = -4
LOAD:00004A3C             arg_8           =  8
LOAD:00004A3C
LOAD:00004A3C 04 70 2D E5                 STR             R7, [SP,#-4]!
LOAD:00004A40 00 70 0F E1                 MRS             R7, CPSR
LOAD:00004A44 04 20 2D E5                 STR             R2, [SP,#-4]!
LOAD:00004A48 01 10 CE E3                 BIC             R1, LR, #1
LOAD:00004A4C 80 01 B1 E7                 LDR             R0, [R1,R0,LSL#3]!
LOAD:00004A50 04 10 91 E5                 LDR             R1, [R1,#4]
LOAD:00004A54 00 00 51 E3                 CMP             R1, #0
LOAD:00004A58 0E 00 00 0A                 BEQ             loc_4A98
LOAD:00004A5C 01 00 11 E3                 TST             R1, #1
LOAD:00004A60 7F 20 A0 13                 MOVNE           R2, #0x7F ; ''
LOAD:00004A64 21 22 02 10                 ANDNE           R2, R2, R1,LSR#4
LOAD:00004A68 02 00 40 10                 SUBNE           R0, R0, R2
LOAD:00004A6C 02 00 11 E3                 TST             R1, #2
LOAD:00004A70 7F 20 A0 13                 MOVNE           R2, #0x7F ; ''
LOAD:00004A74 A1 25 02 10                 ANDNE           R2, R2, R1,LSR#11
LOAD:00004A78 02 00 80 10                 ADDNE           R0, R0, R2
LOAD:00004A7C 04 00 11 E3                 TST             R1, #4
LOAD:00004A80 FF 20 A0 13                 MOVNE           R2, #0xFF
LOAD:00004A84 21 29 02 10                 ANDNE           R2, R2, R1,LSR#18
LOAD:00004A88 02 00 20 10                 EORNE           R0, R0, R2
LOAD:00004A8C 01 2E A0 E1                 MOV             R2, R1,LSL#28
LOAD:00004A90 C2 0F 20 E0                 EOR             R0, R0, R2,ASR#31
LOAD:00004A94 21 0D 80 E0                 ADD             R0, R0, R1,LSR#26
LOAD:00004A98
LOAD:00004A98             loc_4A98                                ; CODE XREF: sub_4A3C+1Cj
LOAD:00004A98 0E 00 80 E0                 ADD             R0, R0, LR
LOAD:00004A9C 04 20 9D E4                 LDR             R2, [SP],#4
LOAD:00004AA0 07 F0 29 E1                 MSR             CPSR_cf, R7
LOAD:00004AA4 04 70 9D E4                 LDR             R7, [SP],#4
LOAD:00004AA8 08 E0 9D E5                 LDR             LR, [SP,#8]
LOAD:00004AAC 08 00 8D E5                 STR             R0, [SP,#8]
LOAD:00004AB0 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC}
LOAD:00004AB0             ; End of function sub_4A3C

----------------------------------------------------------------------------------------------
在拿一個調整表做例子：
LOAD:00009884 01 48                       LDR             R0, =5
LOAD:00009888 FB F7 60 E8                 BLX             dyna_pc
LOAD:0000988C 05 00 00 00 dword_988C      DCD 5            
LOAD:00009890 1C 00 00 00                 DCD 0x1C
LOAD:00009894 40 00 00 00                 DCD 0x40
LOAD:00009898 E4 00 00 00                 DCD 0xE4
LOAD:0000989C 3C 01 00 00                 DCD 0x13C
LOAD:000098A0 88 01 00 00                 DCD 0x188
LOAD:000098A4 08 02 00 00                 DCD 0x208
同上，規律是dyna_pc + 4 (即下一條指令地址[是r0的值] + offset[0 - 5], 因爲表大小為9890 - 98A4 共5個)，
因此證明一共5個跳轉經過這裏，經證明確實如此：
Down j LOAD:000098C4 BL              loc_9888
Down j LOAD:00009966 BL              loc_9888
Down j LOAD:000099BE BL              loc_9888
Down j LOAD:00009A0C BL              loc_9888
Down j LOAD:00009A8A BL              loc_9888
-------------------------------------------------------------------------------------------
sub_494C的特征，代码段中仅存在一处
LOAD:0000B264 ; ---------------------------------------------------------------------------
LOAD:0000B264                 PUSH.W          {R4-R8,LR}
LOAD:0000B268                 ADD             R7, SP, #0xC
LOAD:0000B26A                 PUSH            {R0,R1,LR}
LOAD:0000B26C                 LDR             R0, =0x20
LOAD:0000B26E                 BL              loc_B140   // 又跳回了LOAD:0000B140                 BLX             sub_494C
LOAD:0000B26E ; ---------------------------------------------------------------------------
可以看到并想象程序中有多种类似的跳转，
特征：
PUSH            {R0,R1,LR}  
LDR             R0, =number
NOP
patch代码摘自网络，被放置在put_unconditional_branch.py文件中，
在B26A处执行patch脚本，运行结果如下：B26A处指令变成了B loc_B4B0
LOAD:0000B264             ; ---------------------------------------------------------------------------
LOAD:0000B264 2D E9 F0 41                 PUSH.W          {R4-R8,LR}
LOAD:0000B268 03 AF                       ADD             R7, SP, #0xC
LOAD:0000B26A 21 E1                       B               loc_B4B0
LOAD:0000B26C 01 48                       LDR             R0, =0x20
LOAD:0000B26E FF F7 67 FF                 BL              loc_B140
LOAD:0000B26E             ; ---------------------------------------------------------------------------

LOAD:0000B4B0             ; ---------------------------------------------------------------------------
LOAD:0000B4B0
LOAD:0000B4B0             loc_B4B0
LOAD:0000B4B0 82 B0                       SUB             SP, SP, #8
LOAD:0000B4B2 82 B0                       SUB             SP, SP, #8 // 这段代码包含一个blx跳转，该跳转
LOAD:0000B4B4 03 B5                       PUSH            {R0,R1,LR} //	仅仅是完成了跳到下一个指令的位置
LOAD:0000B4B6 F9 F7 56 EA                 BLX             sub_4964   //	并且计算出指定寄存器的值
LOAD:0000B4BA EA 00                       LSLS            R2, R5, #3 //	这段类似代码都可以被patch掉
LOAD:0000B4BC 00 00                       MOVS            R0, R0 //
LOAD:0000B4BE 02 BC                       POP             {R1} //
LOAD:0000B4C0 00 28                       CMP             R0, #0 //
LOAD:0000B4C2 79 44                       ADD             R1, PC //
LOAD:0000B4C4 09 68                       LDR             R1, [R1] 
LOAD:0000B4C6 03 B5                       PUSH            {R0,R1,LR}
LOAD:0000B4C8 01 48                       LDR             R0, =0x27
LOAD:0000B4CA FF F7 39 FE                 BL              loc_B140
LOAD:0000B4CA             ; ---------------------------------------------------------------------------



sub_4964处指令只是完成了 PC = R1 = B5A4, LR = B4BE(它下一条指令处)， R0, R1略
LOAD:00004964             ; =============== S U B R O U T I N E =======================================
LOAD:00004964
LOAD:00004964
LOAD:00004964             sub_4964                               
LOAD:00004964                                                     
LOAD:00004964
LOAD:00004964             arg_C           =  0xC
LOAD:00004964             arg_10          =  0x10
LOAD:00004964
LOAD:00004964 01 00 CE E3                 BIC             R0, LR, #1  // LR最低位清零，最终R0仍为B4BA
LOAD:00004968 00 10 90 E5                 LDR             R1, [R0] // R1 = [B4BA] = 0XEA
LOAD:0000496C 01 10 90 E7                 LDR             R1, [R0,R1] // R1 = B4BA + 0XEA = B5A4
LOAD:00004970 04 E0 8E E2                 ADD             LR, LR, #4 // B4BA + 4 = B4BE
LOAD:00004974 0C E0 8D E5                 STR             LR, [SP,#0xC]
LOAD:00004978 10 10 8D E5                 STR             R1, [SP,#0x10]
LOAD:0000497C 03 C0 BD E8                 LDMFD           SP!, {R0,R1,LR,PC} // PC = B4BE(它下一条指令处)
LOAD:0000497C             ; End of function sub_4964
LOAD:0000497C
LOAD:00004980             ; ---------------------------------------------------------------------------

特征如下：
SUB SP, SP, #8
PUSH {R0,R1,LR}
....
POP xxx
摘自网络的patch代码见patches.py文件，在B4B2处进行patch后代码变化如下：
LOAD:0000B4B0             ; ---------------------------------------------------------------------------
LOAD:0000B4B0
LOAD:0000B4B0             loc_B4B0
LOAD:0000B4B0 82 B0                       SUB             SP, SP, #8
LOAD:0000B4B2 00 BF                       NOP
LOAD:0000B4B4 01 49                       LDR             R1, =0xB5A4 // = 0x7F73A  
LOAD:0000B4B6 09 68                       LDR             R1, [R1]
LOAD:0000B4B8 02 E0                       B               loc_B4C0
LOAD:0000B4B8             ; ---------------------------------------------------------------------------
LOAD:0000B4BA EA 00       word_B4BA       DCW 0xEA
LOAD:0000B4BC A4 B5 00 00 dword_B4BC      DCD 0xB5A4
LOAD:0000B4C0             ; ---------------------------------------------------------------------------
LOAD:0000B4C0
LOAD:0000B4C0             loc_B4C0                                ; CODE XREF: LOAD:0000B4B8j
LOAD:0000B4C0 00 28                       CMP             R0, #0
LOAD:0000B4C2 79 44                       ADD             R1, PC //  __stack_chk_guard
LOAD:0000B4C4 09 68                       LDR             R1, [R1]
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
另一块类似代码，特征：

LOAD:0007203C 03 B5                       PUSH            {R0,R1,LR}
LOAD:0007203E 00 BF                       NOP
LOAD:00072040 92 F7 AA EC                 BLX             sub_4998
LOAD:00072044 0C 00                       MOVS            R4, R1
-------------------------------------------------------------------------------------------------------------------

LOAD:00004998
LOAD:00004998
LOAD:00004998             sub_4998                              
LOAD:00004998                                                     
LOAD:00004998
LOAD:00004998             arg_8           =  8
LOAD:00004998
LOAD:00004998 01 00 CE E3                 BIC             R0, LR, #1 // 对LR = 0x72044最低位清零，仍为72044
LOAD:0000499C 00 10 90 E5                 LDR             R1, [R0] // 取R1 = [0x72044] = 0xc
LOAD:000049A0 0E 10 81 E0                 ADD             R1, R1, LR // 对LR = 0x72044 + 0xc = 0x72050 
LOAD:000049A4 08 E0 9D E5                 LDR             LR, [SP,#8]
LOAD:000049A8 08 10 8D E5                 STR             R1, [SP,#8]
LOAD:000049AC 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC} // PC = 0x72050 
LOAD:000049AC             ; End of function sub_4998

----------------------------------------------------------------------------------------------------------------
摘自网络命名位put_unconditional_branch1.py文件patch 0x7203C。

LOAD:0007203C                 B               loc_72050
LOAD:0007203E                 NOP
LOAD:00072040                 BLX             sub_4998
LOAD:00072044                 MOVS            R4, R1
LOAD:00072046                 MOVS            R0, R0

---------------------------------------------------------------------------------------------------------------
另一種計算pc的特徵：
LOAD:00009A50 FA F7 A2 EF                 BLX             sub_4998
LOAD:00009A50             ; ---------------------------------------------------------------------------
LOAD:00009A54 7A FF FF FF                 DCD 0xFFFFFF7A
LOAD:00009A58             ; ---------------------------------------------------------------------------

sub_4998
LOAD:00004998             arg_8           =  8
LOAD:00004998
LOAD:00004998 01 00 CE E3                 BIC             R0, LR, #1 // lr = 9A54
LOAD:0000499C 00 10 90 E5                 LDR             R1, [R0] // 0xFFFFFF7A
LOAD:000049A0 0E 10 81 E0                 ADD             R1, R1, LR  // 0x9ace = 9A54 + 0x7a
LOAD:000049A4 08 E0 9D E5                 LDR             LR, [SP,#8]
LOAD:000049A8 08 10 8D E5                 STR             R1, [SP,#8]
LOAD:000049AC 03 80 BD E8                 LDMFD           SP!, {R0,R1,PC} // 0x9ace
以上指令等價於下面僞代碼：
bl (lr + [lr])
---------------------------------------------------------------------------------------------------------------
另一種計算pc的特徵:
LOAD:00009BBC 00 F0 0C B8                 B.W             loc_9BD8
LOAD:00009BC0             ; ---------------------------------------------------------------------------


LOAD:00009BD8             loc_9BD8    
LOAD:00009BD8                              
LOAD:00009BD8 71 46                       MOV             R1, LR // lr = 9BC0 
LOAD:00009BDA 02 A5                       ADR             R5, 0x9BE4
LOAD:00009BDC 55 F8 21 10                 LDR.W           R1, [R5,R1,LSL#2] ; 30ae4 = 0xFE6B
LOAD:00009BE0 29 44                       ADD             R1, R5  ; 19A4F
LOAD:00009BE2 08 47                       BX              R1 // 動態跳轉
LOAD:00009BE2             ; ---------------------------------------------------------------------------
LOAD:00009BE4 DD FF FF FF                 DCD 0xFFFFFFDD
LOAD:00009BE8             ; ---------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------
另一種計算pc的特徵（同時動態計算寄存器值，參數動態生成）：
LOAD:00004D12 82 B0                       SUB             SP, SP, #8
LOAD:00004D14 03 B5                       PUSH            {R0,R1,LR}
LOAD:00004D16 FF F7 26 EE                 BLX             sub_4964 
LOAD:00004D16             ; ---------------------------------------------------------------------------
LOAD:00004D1A EE 31 00 00                 DCD 0x31EE
LOAD:00004D1E             ; ---------------------------------------------------------------------------
LOAD:00004D1E 01 BC                       POP             {R0} // pop xxx，動態生成參數

sub_4964 
LOAD:00004964 01 00 CE E3                 BIC             R0, LR, #1 // 4D1A
LOAD:00004968 00 10 90 E5                 LDR             R1, [R0] // 0x31EE
LOAD:0000496C 01 10 90 E7                 LDR             R1, [R0,R1] // r1 = [4D1A + 0x31EE] = [7f08] = 0x85ECC
LOAD:00004970 04 E0 8E E2                 ADD             LR, LR, #4 // lr = 4D1E
LOAD:00004974 0C E0 8D E5                 STR             LR, [SP,#0xC] // lr + 4 ,下一條指令処
LOAD:00004978 10 10 8D E5                 STR             R1, [SP,#0x10] // 待彈出寄存器值0x85ECC
LOAD:0000497C 03 C0 BD E8                 LDMFD           SP!, {R0,R1,LR,PC} // pc = pc + 8
等同於僞代碼：
arg_addr = [lr + [lr]]
r{0-3} = arg_addr
---------------------------------------------------------------------------------------------------------------
程序JNI_OnLoad邏輯：
libsgmainso_6.4.36.so B3F2D000 B3FB6000 R . X D . byte 00 public CODE 32 00 00
sp = BE903640  B1200284  debug038:B1200284
第一個動態pc：
libsgmainso_6.4.36.so:B3F38140 BLX             dyna_pc
動態arg：
libsgmainso_6.4.36.so:B3F384B6 BLX             dyna_arg
libsgmainso_6.4.36.so:AFE80210 BL              loc_AFEF14F4(重命名為goto_create_global_objs)
sub_7C4F4();   // 創建全局 jboolean， jinteger、jstring

调试时跳过这里，否则可能崩溃
LOAD:0000B584 71 F0 14 F8                 BL              goto_getenv
---------------------------------------------------------------------------------------------------------------
#sub_72CCC()，被重命名為goto_do_httpuitl
主要完成對com/taobao/wireless/security/adapter/common/HttpUtil的各種方法的查找
獲取對應的MethodId並保存

sub77dbc(), 代码複合patch代码第二種特征，但是这里应该不被patch，被patch的地方
82 B0       SUB             SP, SP, #8
03 B5       PUSH            {R0,R1,LR}
91 F7 CC ED BLX             dyna_arg
32 01       LSLS            R2, R6, #4
00 00       MOVS            R0, R0
01 BC       POP             {R0}
应该满足两个SUB             SP, SP, #8指令，因此運行patch代碼，patch整個代碼段
會出錯，它會把{R0,R1,LR}指令patch成b xxxx導致運行失敗。
sp = BE903620  AFE80111  libsgmainso_6.4.36.so:AFE80111
BL              sub_B3FA0E24(sub_73e24()，被重命名為goto_decrypt_entry)
arg:B3FB2FA9, BE9035C3,0x35 // 參數1為加密數據緩存區，參數2是解密數據緩存區
sub_B3FA0E56(sub_73e56, 被重命名為decrypt_entry),比較重要的函數涉及創建容器結構體和解密
BL unk_B3FA7F78(goto_create_vdata)
BL sub_B3FA7FB6(create_vdata)
arg:vdata1,"DcO/lcK+h?m3c*q@",0x10
//vdata1->make_vdata 填充數據
libsgmainso_6.4.36.so:B3FA0E94 98 47 BLX     R3(7AA5D‬)
拷貝"DcO/lcK+h?m3c*vaq@"到vdata1的data1中

第二次調用make_vdata，arg:vdata2,B3FB2FA9,52 // 參數2是數據緩存區
這次是把下面這52個字節拷貝到vdata2的data2中
0xF9,0xA7,0x21,0x3D,0x8C,0x3E,0xFE,0x77,0x18,0x40,0xDB,0x2A,
0xAD,0x4A,0xC5,0xF9,0xA1,0x56,0x75,0x54,0x23,0xBE,0xC7,0xA6, 
0x7A,0x35,0xEC,0x8E,0xB2,5,0x74,0x11,0x93,0x58,0x7F,0x6E,0x3A,
0xE3,0x4F,0x9D,0x54,3,0x7E,0x6B,0xFA,0x1B,0x5B,0xE3,0xF8,0xC1,2,0xF9 
dcryptdata:BE903578
memset(BE903578, 0, 20)
arg:BE903578,BE903594,20,20
// 進入解密函數，dcryptdata結構對應内存
[stack]:BE903578 DCD 0
[stack]:BE90357C DCD 3 ; caseno
[stack]:BE903580 DCD 0
[stack]:BE903584 DCD 0
[stack]:BE903588 DCD 0xACC1C890 ; vdata1
[stack]:BE90358C DCD 0xACC1C8C8 ; vdata2
libsgmainso_6.4.36.so:B3FA0ED8 BL       sub_B3F8E15C(重命名為goto_dcrypto)
goto_dcrypto(dcryptdata, )
進入sub_611b4(被重命名為decrypto)進行解密，解密出：
"com/taobao/wireless/security/adapter/common/HttpUtil"
libsgmainso_6.4.36.so AFE75000 AFEFE000 R . X D . byte 00 public CODE 32 00 00
調用findclass查找該class，調用NewGlobalRef創建該類的ref
arg: httputilref, 
bl sub_72d60()
// 參數1加密數據，參數2為解密緩衝區，參數3為長度
BL              goto_decrypt_entry(encdata, decdata, len);
BL              goto_create_vdata
memset (BE9035A0, 0, 0x1d)
拷貝加密數據到vdata2
memset dcryptdata 結構BE903558
BL              goto_dcrypto, 解密出字符串"sendSyncHttpGetRequestBridge" 
調用env->getStaticMethodID,75F247D8
sub_72e54()
解密出數據"sendSyncHttpPostRequestBridge"
調用env->getStaticMethodID, 75F24828
在解密出"downloadFileBridge" 
調用env->getStaticMethodID, 75F24788
調用env->DeleteLocalRef刪除httputilref
至此sub_72CCC()結束
---------------------------------------------------------------------------------------------------------------
sub_73634()被重命名為goto_do_umidAdapter
主要完成對com/taobao/wireless/security/adapter/umid/UmidAdapter的方法的查找
並保存其MethodId
sub_7366A‬()
BL    goto_decrypt_entry(,, 54)
解密出"com/taobao/wireless/security/adapter/umid/UmidAdapter"
調用env->findclass找到UmidAdapterClass 00100025,調用env->NewGlobalRef UmidAdapterRef
調用env->DeleteLocalRef, 刪除UmidAdapterClass
BL    goto_decrypt_entry(AFEFB113, BE9035B8, 16)
解密出"umidInitAdapter"
調用env->getStaticMethodID(UmidAdapterRef, "umidInitAdapter") 75F248C8
sub_73634()結束
---------------------------------------------------------------------------------------------------------------
sub_73E24()      goto_decrypt_entry(AFEF8EA6, BE9035E8, 49)
解密出"com/taobao/wireless/security/adapter/JNICLibrary"
libsgmainso_6.4.36.so B3F2E000 B3FB7000 R . X D . byte 00 public CODE 32 00 00
調用env->findclass查找JNICLibrary 00200025
bl 9EE4‬
sub_9ee4() 被重命名為goto_create_tmp1vdata_，主要是調用sub_9F1C完成創建兩個大的結構體
sub_9F1C()
ACC11F60 = malloc(12); // 這是個什麽結構體,暫且命名為tmp_vdata
debug014:ACC11F60 DCD 0xB3F36A99
debug014:ACC11F64 DCD 0xB3F36DF5
debug014:ACC11F68 DCD 0xB3F36E49
sub_7B86C(32,0) // 重命名為create_tmp1vdata(int len, int w); // len表示結構體大小，w未知
struct tmp1_nest_struct {
	void* tmp1_nf1;
	void* tmp1_nf2;
	int len;
};

struct tmp1_vdata {
	struct data* datalist;
	int chunk_count;
	int chunk_size;
	void* tmp1_f1;
	void* tmp1_f2;
	void* tmp1_f3;
	struct tmp1_nest_struct tmp1_nest;
};
ACC3A3D0 = malloc(36);
創建tmp1_vdata結構體，對應内存結構：
debug014:ACC3A3D0 DCD 0xACC49300                          ; tmp1_vdata1
debug014:ACC3A3D4 DCD 0
debug014:ACC3A3D8 DCD 0x20
debug014:ACC3A3DC DCD 0xB3FA88F9
debug014:ACC3A3E0 DCD 0xB3FA89B5
debug014:ACC3A3E4 DCD 0xB3FA89F5
debug014:ACC3A3E8 DCD 0xB3FA8A81
debug014:ACC3A3EC DCD 0xB3FA8AF1
debug014:ACC3A3F0 DCD 0
創建data結構體(chunk)
ACC49300 = malloc(128);

創建第二個tmp1_vdata結構體ACC3A3A8
debug014:ACC3A3A8 DCD 0xACC49280                          ; tmp1_vdata2
debug014:ACC3A3AC DCD 0
debug014:ACC3A3B0 DCD 0x20
debug014:ACC3A3B4 DCD 0xB3FA88F9
debug014:ACC3A3B8 DCD 0xB3FA89B5
debug014:ACC3A3BC DCD 0xB3FA89F5
debug014:ACC3A3C0 DCD 0xB3FA8A81
debug014:ACC3A3C4 DCD 0xB3FA8AF1
debug014:ACC3A3C8 DCD 0
創建第二個data結構體ACC49280
然後把它倆存儲在以下地方：
libsgmainso_6.4.36.so:B3FB9A78 gtmp1_data2 DCD 0xACC3A3A8 
libsgmainso_6.4.36.so:B3FB9A7C gtmp1_data1 DCD 0xACC3A3D0 
---------------------------------------------------------------------------------------------------------------
bl sub_71D68()‬,重命名為goto_do_SPUtility2
主要是查找com/taobao/wireless/security/adapter/common/SPUtility2的一些methoidID
sub_sub_73DD4()啥也沒乾

sub_71E70只是用來構造參數
sub_72080()
解密得到"com/taobao/wireless/security/adapter/common/SPUtility2"
調用env->findclass找到SPUtility2Class 00000029
調用env->NewGlobalRef創建SPUtility2Ref 001003DA
sub_72134()
解密"readFromSPUnified"
調用env-getStaticMethodID, 75F26B48
解密"saveToFileUnifiedForNative"
調用env-getStaticMethodID, 75F26C88
sub_720C8‬()
解密出 "removeFromSPUnifiedp"
調用env-getStaticMethodID, 75F26BE8
sub_71FD0‬()
解密出"readSS"
解密出"writeSS"，調用env-getStaticMethodID, 75F26D78
sub_71EB0()
調用env-getStaticMethodID("readSS"), 75F26B98
解密出"read"， "write"
調用env-getStaticMethodID("read"),75F26AF8
調用env-getStaticMethodID("write"),75F26D28
---------------------------------------------------------------------------------------------------------------
sub_e7dc()
sub_E890‬()
解密出"(I)Ljava/lang/String;"
解密出"com/taobao/wireless/security/adapter/datacollection/DeviceInfoCapturer"
調用findclass，0010002D，調用NewGlobalRef創建該類的ref 001003DE
調用DeleteLocalRef, 刪除本地DeviceInfoCapturer類的ref
解密出"doCommandForString"
調用env-getStaticMethodID("doCommandForString"),75F27048
存儲在以下位置：
libsgmainso_6.4.36.so:B3FB9A94 global_DeviceInfoCapturer_methodId DCD 0x75F27048
libsgmainso_6.4.36.so:B3FB7C00 global_DeviceInfoCapturer_ref DCD 0xB6F33E04

sub_9B3C‬(), 不知道在幹嘛，一堆跳和賦值，感覺向被llvm混淆過，


sub_9854() 它會記錄時間
struct 8bitstruct {
	int count;
	struct tmp1_vdata* vdata;
};

8bitstruct = B4F01130 = malloc(8); 暫時不知道代表啥
debug070:B4F01130 DCD 1                                   ; 8字節數據，裏面存儲著tmp1_vdata3
debug070:B4F01134 DCD 0xACC3A3F8                          ; tmp1_vdata3

再次調用create_tmp1vdata
debug014:ACC3A3F8 DCB 0                                   ; tmp1_vdata3
debug014:ACC49380 DCB    0                                ; tmp1_data3

sub_7B93A(tmp1_vdata2, 0， B4F01130); //tmp1_vdata的函數f2，填充數據
執行完畢tmp1_vdata2變爲：
debug014:ACC3A3A8 DCD 0xACC49280                          ; tmp1_vdata2
debug014:ACC3A3AC DCD 1
debug014:ACC3A3B0 DCD 0x20
debug014:ACC3A3B4 DCD 0xB3FA88F9
debug014:ACC3A3B8 DCD 0xB3FA89B5
debug014:ACC3A3BC DCD 0xB3FA89F5
debug014:ACC3A3C0 DCD 0xB3FA8A81
debug014:ACC3A3C4 DCD 0xB3FA8AF1
debug014:ACC3A3C8 DCD 0

debug014:ACC49280 DCD 0xB4F01130                          ; tm1_data2; 指向了B4F01130
sub_9970‬()
ACC125B0 = malloc(24);
struct 24bitstruct {
	int a; // 1
	int b; // 9
	long time;
	int c;
	struct *tmp1_vdata vdata; // tmp1_vdata4
	int d;
};
調用time,srand48,lrand48

debug014:ACC125B0 DCD 1                                   ; 24字節的結構,第三個四字節為時間
debug014:ACC125B4 DCD 9
debug014:ACC125B8 DCD 0x26BD7CF6
debug014:ACC125BC DCD 0
debug014:ACC125C0 DCD 0xACC3A498 ;tmp1_vdata4
debug014:ACC125C4 DCD 0

在調用goto_create_tmp1vdata
debug014:ACC3A498 DCB    0                                ; tmp1_vdata4
debug014:ACC49400 DCB 0x52 ; R                            ; tmp1_data4

ACC11F80 = malloc(16); // 16字節的結構
debug014:ACC11F80 DCD 1                                   ; 16字節結構
debug014:ACC11F84 DCD 9
debug014:ACC11F88 DCD 1
debug014:ACC11F8C DCD 0x954EAE43

struct 16bitstruct {
	int t;
	int lrand;
	int random;
	int sec;
};

繼續調用tmp1_vdata的函數f2(tmp1_vdata4, 0, ACC11F80);tmp1_vdata4變爲：
debug014:ACC3A498 DCD 0xACC49400                          ; tmp1_vdata4
debug014:ACC3A49C DCD 1
debug014:ACC3A4A0 DCD 0x20

debug014:ACC49400 DCD 0xACC11F80                          ; tmp1_data4, 指向ACC11F80，16字節的結構
sub_9854() 結束
TODO 有可能拉下東西了
---------------------------------------------------------------------------------------------------------------
libsgmainso_6.4.36.so B3F2D000 B3FB6000 R . X D . byte 00 public CODE 32 00 00
sub_69D68‬() 啥也沒乾
---------------------------------------------------------------------------------------------------------------
sub_197B4() 被重命名為goto_do_DataReportJniBridgerer
主要是處理com/taobao/wireless/security/adapter/datareport/DataReportJniBridgerer這個類的方法，同上
sub_1990C‬()
解密出"com/taobao/wireless/security/adapter/datareport/DataReportJniBridgerer"
調用findclass， 0000002D
調用NewGlobalRef創建該類的ref 001003E2
sub_19998‬()
下面忘記下斷點了，丟失信息了
解密出"sendReportBridge", 調用getStaticMethodID, 忘記記錄了
解密出 "accsAvaiableBridge", 調用getStaticMethodID, 忘記記錄了
解密出"()I" , 調用getStaticMethodID, 忘記記錄了
解密出"registerAccsListnerBridge"
解密出"()I" , 調用getStaticMethodID, 忘記記錄了
sub_73D90()‬ 啥也沒乾
又sub_9B3C‬()它裏面會調用sub_9854()，會創建很多結構並記錄時間,可能是執行時間校驗？還是
時間記錄打點？

丟掉了記錄8字節内存
8bitstruct = ？？ = malloc(8); 暫時不知道代表啥
debug014:ACC3A4C0 DCD 0xACC49480                          ; tmp1_vdata4

24bitstruct = debug014:ACC125E0 = malloc(24)
debug014:ACC125E0 DCD 1                                   ; 24bitstruct2
debug014:ACC125E4 DCD 0xB
debug014:ACC125E8 DCD 0x7FF75E63
debug014:ACC125EC DCD 0
debug014:ACC125F0 DCD 0xACC3A4C0 ; tmp1_vdata4
debug014:ACC125F4 DCD 0

ACC11FC0 = malloc(16);
debug014:ACC11FC0 DCD 1                                   ; 16bit結構
debug014:ACC11FC4 DCD 0xB
debug014:ACC11FC8 DCD 0x34
debug014:ACC11FCC DCD 0xCC033946

調用完tmp1_vdata的函數f2
debug014:ACC3A4C0 DCD 0xACC49480                          ; tmp1_vdata4
debug014:ACC3A4C4 DCD 1
debug014:ACC3A4C8 DCD 0x20

debug014:ACC49480 DCD 0xACC11FC0                          ; tmp1_data4
---------------------------------------------------------------------------------------------------------------
sub_E240‬()
sub_e280()
又sub_9B3C‬(),被我重命名為complex_time_struct，它裏面會調用sub_9854()，會創建很多結構並記錄時間

debug014:ACC126A0 DCD 1                                   ; 24bitstruct
debug014:ACC126A4 DCD 7
debug014:ACC126A8 DCD 0x21A74169
debug014:ACC126AC DCD 0

debug014:ACC3A4E8 DCD 0xACC49500                          ; tm1_vdata5
debug014:ACC49500 DCD 0xACC11FF0                          ; tmp1_data5; //最終指向16bitstruct


debug014:ACC11FF0 DCD 1                                   ; 16bitstruct
debug014:ACC11FF4 DCD 7
debug014:ACC11FF8 DCD 1
debug014:ACC11FFC DCD 0x9254F0BC
---------------------------------------------------------------------------------------------------------------
sub_B8B0()‬
繼續調用complex_time_struct
到此我先更新一下上面的tmp1_vdata和tmp1_data
=============================================================================
debug014:ACC3A3D0 DCD 0xACC49300                          ; tmp1_vdata1
debug014:ACC3A3D4 DCD 0 ; 代表無數據
debug014:ACC3A3D8 DCD 0x20
debug014:ACC3A3DC DCD 0xB3FA88F9
debug014:ACC3A3E0 DCD 0xB3FA89B5
debug014:ACC3A3E4 DCD 0xB3FA89F5
debug014:ACC3A3E8 DCD 0xB3FA8A81
debug014:ACC3A3EC DCD 0xB3FA8AF1
debug014:ACC3A3F0 DCD 0

debug014:ACC49300 DCB    0                                ; tmp1_data1
=============================================================================
debug014:ACC3A3A8 DCD 0xACC49280                          ; tmp1_vdata2
debug014:ACC3A3AC DCD 1 ; 代表存在一個數據
debug014:ACC3A3B0 DCD 0x20
debug014:ACC3A3B4 DCD 0xB3FA88F9
debug014:ACC3A3B8 DCD 0xB3FA89B5
debug014:ACC3A3BC DCD 0xB3FA89F5
debug014:ACC3A3C0 DCD 0xB3FA8A81
debug014:ACC3A3C4 DCD 0xB3FA8AF1
debug014:ACC3A3C8 DCD 0

debug014:ACC49280 DCD 0xB4F01130                          ; tm1_data2
=============================================================================
debug014:ACC3A3F8 DCD 0xACC49380                          ; tmp1_vdata3
debug014:ACC3A3FC DCD 3 ; 代表存在三個數據
debug014:ACC3A400 DCD 0x20
debug014:ACC3A404 DCD 0xB3FA88F9
debug014:ACC3A408 DCD 0xB3FA89B5
debug014:ACC3A40C DCD 0xB3FA89F5
debug014:ACC3A410 DCD 0xB3FA8A81
debug014:ACC3A414 DCD 0xB3FA8AF1
debug014:ACC3A418 DCD 0

debug014:ACC49380 DCD 0xACC125B0                          ; tmp1_data3
debug014:ACC49384 DCD 0xACC125E0
debug014:ACC49388 DCD 0xACC126A0
=============================================================================
debug014:ACC3A4C0 DCD 0xACC49480                          ; tmp1_vdata4
debug014:ACC3A4C4 DCD 1 ; 代表存在一個數據
debug014:ACC3A4C8 DCD 0x20
debug014:ACC3A4CC DCD 0xB3FA88F9
debug014:ACC3A4D0 DCD 0xB3FA89B5
debug014:ACC3A4D4 DCD 0xB3FA89F5
debug014:ACC3A4D8 DCD 0xB3FA8A81
debug014:ACC3A4DC DCD 0xB3FA8AF1
debug014:ACC3A4E0 DCD 0

debug014:ACC49480 DCD 0xACC11FC0                          ; tmp1_data4
=============================================================================
debug014:ACC3A4E8 DCD 0xACC49500                          ; tm1_vdata5
debug014:ACC3A4EC DCD 1 ; 代表存在一個數據
debug014:ACC3A4F0 DCD 0x20
debug014:ACC3A4F4 DCD 0xB3FA88F9
debug014:ACC3A4F8 DCD 0xB3FA89B5
debug014:ACC3A4FC DCD 0xB3FA89F5
debug014:ACC3A500 DCD 0xB3FA8A81
debug014:ACC3A504 DCD 0xB3FA8AF1
debug014:ACC3A508 DCD 0

debug014:ACC49500 DCD 0xACC11FF0                          ; tmp1_data5
=============================================================================
邏輯中對比
從8bitstruct -> tmp1_vdata -> chunk_count 和 1 對比， 循環
{
取chunk_count個對應的tmp1_data(即24bitstruct代表時間的結構體的第二個字段)逐一對比
}
對比完成在創建上面提到的結構體
24bitstruct = ACC12640

debug014:ACC3A650 DCD 0xACC49580                          ; tmp1_vdata

16bitstruct = ACC33030

上面 ida 崩潰了，導致在分析變得有點混亂
重新分析了一下結構：

tmp1_vdata_list {
 struct tmp1_vdata** vdatalist;
}

sub_9a14(tmp1_vdata* tmp1vdata, int t, int t1, int t2) {
	if ( tmp1vdata->chunk_count >= 1) {
		struct data** datalist = tmp1vdata->datalist;
		for (int i = 0 ; i < tmp1vdata->chunk_count; i++) {
			struct 24bitstruct* 24str = datalist[i];
			if(24str->t == t) {
				struct 8bitstruct* 8str = arg;
				struct tmp1_vdata* vdata =  arg->vdata;
				int chunk_count = vdata->chunk_count;
				if (chunk_count >= 1) {
					struct 24bitstruct* 24str = vdata->datalist;
					for (int j = 0 ; j < chunk_count; j++) {
						struct 24bitstruct* 24str_ = vdata->datalist[i];
						if(24str_->lrand == t1) {
							
						}
						
						24bitstruct 24bitstr = malloc(24);
						time_t seconds;
						seconds = time(NULL);
						srand((unsigned) time(&t));
						int r = rand() >> 31;
					
						24bitstr->time = r;
						24bitstr->a = ?
						24bitstr->b = ?
						24bitstr->sec = ?
						
						// 繼續調用sub_7B86C()‬
						// 獲得tmp1_vdata* = ACC3A650
						// 獲得tmp1_vdata->datalist = ACC4A400
						24bitstr->vdata = ACC3A650;
						tmp1vdata->f2(,) // 0xACC4A200, 邏輯同上
						
						
						16bitstruct 16bitstr  = malloc(0x16); // ACC11DD0
						繼續調用tmp1_vdata* = ACC3A650->f2(ACC3A650, ACC11DD0)
						
						tmp1_vdata*->datalist = 0xACC4A400[ACC11DD0];
						// (EOR.W           R0, R0, R11// R11 = B3E34921 )
						16bitstr->sec = 24bitstr->time ^ r11; // 沒搞明白， 沒有EOR.W
					}
				}
				
			}
		}
	}
}

又sub_9B3C‬()，不分析了，後面看心情在分析，ida崩潰了，讓我記錄的結構對不上了
---------------------------------------------------------------------------------------------------------------
sub_5F0F4‬()
sub_5F11E‬()
sub_9B3C‬() 略
sub_7B93A‬() 相當於make_tmp1_vdata

---------------------------------------------------------------------------------------------------------------
sub_5F0F4(env, clazz)   // 無法命名同 sub_E7DC
sub_9B3C‬() 略
sub_9B3C‬() 略
---------------------------------------------------------------------------------------------------------------
sub_70640(env, clazz)  // 無法命名同 sub_E7DC

sub_9B3C‬() 略
sub_9B3C‬() 略
---------------------------------------------------------------------------------------------------------------
sub_11F3C(env)  
sub_14FEE‬()
sub_1511C()‬，中間很多調用findclass和調用都略
解密出"android/content/Context"，調用findclass
sub_151A4‬()
解密出"getPackageManager","()Landroid/content/pm/PackageManager;"
調用getStaticMethodID 70FC7458
解密出"getContentResolver",  "()Landroid/content/ContentResolver;"
調用getStaticMethodID 70FC7458
解密出"getSystemService"，"(Ljava/lang/String;)Ljava/lang/Object;"
調用getStaticMethodID 70FC7BA8
解密出"WIFI_SERVICE"，"Ljava/lang/String;"
調用GetStaticFieldID 70FC66E8
調用NewGlobalRef創建該類的ref 001003E6
調用DeleteLocalRef刪除該類本地ref
解密出"android/content/pm/PackageManager", "getPackageInfo",，調用findclass
"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"
調用getStaticMethodID 70FAFA30
調用DeleteLocalRef刪除該類本地ref
解密出"android/content/pm/PackageInfo"
"applicationInfo", "Landroid/content/pm/ApplicationInfo;"
調用GetFieldID 71052F08
解密出 "firstInstallTime1"，"J"
調用GetFieldID 71053100
解密出"lastUpdateTime"，"J"
調用GetFieldID 71053118
調用DeleteLocalRef刪除該類本地ref
解密出"android/content/pm/ApplicationInfo","flags","I"
調用GetFieldID 71047168
調用DeleteLocalRef刪除該類本地ref
解密出"android/provider/Settings"， "getString"
"(Landroid/content/ContentResolver;Ljava/lang/String;)Ljava/lang/String;"
調用getStaticMethodID 7127C4E8
調用NewGlobalRef創建該類的ref 001003EA
調用DeleteLocalRef刪除該類本地ref
"java/util/List","get", "(I)Ljava/lang/Object;",
調用getStaticMethodID 70B43A50
解密出"size","()I"
調用getStaticMethodID 70B43DF8
調用DeleteLocalRef刪除該類本地ref
解密出"android/net/wifi/WifiConfiguration"，"SSID"，"Ljava/lang/String;"
調用GetFieldID 75F27C38
"networkId","I",調用GetFieldID 75F28078
"providerFriendlyName","Ljava/lang/String;",調用GetFieldID, 返回空
"BSSID"，"Ljava/lang/String;",調用GetFieldID, 75F27BF8
"FQDN","Ljava/lang/String;",調用GetFieldID, 75F27C18
"priority","I", 調用GetFieldID,75F282B8
"hiddenSSID"，"Z"，調用GetFieldID, 75F27ED8
調用NewGlobalRef創建該類的ref 001003EE
調用DeleteLocalRef刪除該類本地ref
"android/net/wifi/WifiManager"，"getConfiguredNetworks"，"()Ljava/util/List;"
調用getStaticMethodID 711FD720
"getDhcpInfo","()Landroid/net/DhcpInfo;"，
調用getStaticMethodID 711FD840
調用DeleteLocalRef刪除該類本地ref
"android/net/DhcpInfo"， "gateway"，"I",
調用GetFieldID 75F29168
調用DeleteLocalRef刪除該類本地ref
---------------------------------------------------------------------------------------------------------------
sub_21C3C()
sub_21c70()
sub_9b3c() 後面抽時間詳細分析這個多次出現并且經過混淆過的函數
sub_9b3c()
sub_9b3c()
---------------------------------------------------------------------------------------------------------------
sub_2148C()
sub_9b3c()
sub_9b3c()
sub_9b3c()
---------------------------------------------------------------------------------------------------------------
sub_210E0
sub_73D90‬() // 沒幹啥
9A98‬() // goto_create_tmp1_vdata
sub_9b3c()
sub_9b3c()
sub_9b3c()
---------------------------------------------------------------------------------------------------------------
sub_41B58
sub_9b3c()
sub_9b3c()
sub_9b3c()
---------------------------------------------------------------------------------------------------------------
sub_27920
sub_9b3c()
sub_9b3c()
sub_9b3c()
---------------------------------------------------------------------------------------------------------------
sub_293E8()
sub_2941C()->sub_29708()->sub_29918‬()
解密出"com/taobao/dp/util/ZipUtils"，"unZip"，"([B)[B"
findclass找到ZipUtilsClass 00100031
NewGlobalRef 001003F2
DeleteLocalRef
getMethodID 75F29618
解密出"com/taobao/dp/util/CallbackHelper"
findclass找到CallbackHelper 00000031
NewGlobalRef 001003F6
DeleteLocalRef
getMethodID 75F29618
sub_2abf9()-->sub_2AC24‬()加綫程鎖
DeleteLocalRef
sub_29754()->sub_29BB4‬()
解密出"getPackageManager"， "()Landroid/content/pm/PackageManager;"
"android/content/Context","android/content/pm/PackageManager"
"getPackageInfo","(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"
"android/content/pm/PackageInfo","applicationInfo"
"Landroid/content/pm/ApplicationInfo;","firstInstallTime","lastUpdateTime"
"android/content/pm/ApplicationInfo","flags"
FindClass("android/content/Context") 00100031
NewGlobalRef 001003FA
getMethodID("getPackageManager") 70FC7968
FindClass("android/content/pm/PackageManager") 00000035
NewGlobalRef 001003FE
getMethodID("getPackageInfo") 70FAFA30
FindClass("android/content/pm/PackageInfo") 00000039 ??
NewGlobalRef 00100402
GetFieldID("applicationInfo") 71052F08
GetFieldID("firstInstallTime") 71053100
GetFieldID("lastUpdateTime") 71053118
FindClass("android/content/pm/ApplicationInfo") 0000003D
NewGlobalRef 00100406
GetFieldID("flags") 71047168
---------------------------------------------------------------------------------------------------------------
sub_208F4
sub_20A0C‬()
解密出"com/alibaba/wireless/security/framework/utils/UserTrackMethodJniBridge"
NewGlobalRef 0010040A， DeleteLocalRef
"utAvaiable"，"()I;"，getStaticMethodID("utAvaiable") 75F28278
"addUtRecord"，"(Ljava/lang/String;IILjava/lang/String;JLjava/lang/String;"
"Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I"
sprintf(, "%s%s", "(Ljava/lang/String;IILjava/lang/String;JLjava/lang/String;", 
"Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I")
得到"(Ljava/lang/String;IILjava/lang/String;JLjava/lang/String;Ljava/lang/String;Ljava/lang/String;"
"Ljava/lang/String;Ljava/lang/String;)I"
getStaticMethodID("addUtRecord") 75F28188
"getStackTrace","(II)Ljava/lang/String;",getStaticMethodID("getStackTrace"), 75F281D8
判斷獲取的methodId是否為空
---------------------------------------------------------------------------------------------------------------
sub_B7B0
sub_b7f6() 被重命名為registerNatives
解密出"doCommandNative"，"(I[Ljava/lang/Object;)Ljava/lang/Object;", fnPtr為sub_B69C()‬
實際對應sub_B6F6()，重命名為doCommandNative，代碼摘自網絡
sub_9D60為goto_docommand_native_inner
調用env->RegisterNatives()注冊這個doCommandNative
至此JNI_OnLoad結束
---------------------------------------------------------------------------------------------------------------
doCommandNative(12302, new Object[]{1, true}) 對應getSecToken
struct command_arg {
	int arg1;
	int arg2;
	int arg3;
	JNIEnv* env;
	void* args;
};

struct command_arg* = malloc(20); // ACB6A718

int _R4 = 12302; // command
int _R0 = 0x68DB8BAD; // 68DB8BAD
int _R2 = 0x51EB851F; // 51EB851F

int r0 = _R0 * _R4; // 000013AE
int r3 = _R2 * _R4; // 00000F60
// (signed int)r0 >> 0xc) = (signed int) (13AE >> 0xc) = 00000001
// r0 >> 31 = 0
r0 = ((signed int)r0 >> 0xc) + (r0 >> 31); // 0x1, 參數1
int r1 = _R4 - r0 * 10000 ; // 000008FE(2302)
r1 = _R4 * r1; // 2E0, SMMUL.W取高位
// ((signed int)r3 >> 5) = 0000007B(123)
// (r3 >> 31) = 0
r2 = _R4 - (((signed int)r3 >> 5) + (r3 >> 31)) * 100; // 2, 參數3
r3 = (signed) r1 >> 5 = 00000017(23)
r1 = r3 + (r1 >> 31) = 1; // 0x17， 參數2

command_arg->arg1 = 1;
command_arg->arg2 = 0x17;
command_arg->arg3 = 2;


sub_9D60->sub_9D82(1, 0x17, 2, 1, command_arg, 一個棧變量指針)


libsgmainso_6.4.36.so:B3EF7A78 dword_B3EF7A78 DCD 0xACB4A3D0 
// tmp1_vdata
debug021:ACB4A3D0 DCD 0xACB31C80
debug021:ACB4A3D4 DCD 1
debug021:ACB4A3D8 DCD 0x20
debug021:ACB4A3DC DCD 0xB3EE68F9
debug021:ACB4A3E0 DCD 0xB3EE69B5
debug021:ACB4A3E4 DCD 0xB3EE69F5
debug021:ACB4A3E8 DCD 0xB3EE6A81
debug021:ACB4A3EC DCD 0xB3EE6AF1
debug021:ACB4A3F0 DCD 0
// data
debug021:ACB31C80 DCD 0xB4E01130
//
debug068:B4E01130 DCD 1
debug068:B4E01134 DCD 0xACB4A3F8

// tmp1_vdata1
debug021:ACB4A3F8 DCD 0xACB31D00
debug021:ACB4A3FC DCD 0xC
debug021:ACB4A400 DCD 0x20
debug021:ACB4A404 DCD 0xB3EE68F9
debug021:ACB4A408 DCD 0xB3EE69B5
debug021:ACB4A40C DCD 0xB3EE69F5
debug021:ACB4A410 DCD 0xB3EE6A81
debug021:ACB4A414 DCD 0xB3EE6AF1
// 12個data
debug021:ACB31D00 DCD 0xACB125F8
debug021:ACB31D04 DCD 0xACB12610
debug021:ACB31D08 DCD 0xACB125E0
debug021:ACB31D0C DCD 0xACB124C0
debug021:ACB31D10 DCD 0xACB12490
debug021:ACB31D14 DCD 0xACB124F0
debug021:ACB31D18 DCD 0xACB12A00
debug021:ACB31D1C DCD 0xACB12778
debug021:ACB31D20 DCD 0xACB12910
debug021:ACB31D24 DCD 0xACB12AC0
debug021:ACB31D28 DCD 0xACB12970
debug021:ACB31D2C DCD 0xACB12BE0

// 最後取到的符合要求的 對應參數2的結構
debug021:ACB12BE0 DCD 1
debug021:ACB12BE4 DCD 0x17
debug021:ACB12BE8 DCD 0x7A005EB3
debug021:ACB12BEC DCD 0
debug021:ACB12BF0 DCD 0xACB4A7B8
debug021:ACB12BF4 DCD 0
debug021:ACB12BF8 DCD 0
debug021:ACB12BFC DCD 0
debug021:ACB12C00 DCD 0xACB12BC8

//最後取到的符合要求的 對應參數3的結構
debug021:ACB3B340 DCD 1
debug021:ACB3B344 DCD 0x17
debug021:ACB3B348 DCD 2
debug021:ACB3B34C DCD 0xC9E91B96
debug021:ACB3B350 DCD 1
debug021:ACB3B354 DCD 0x17
debug021:ACB3B358 DCD 1
debug021:ACB3B35C DCD 0xC9E91A22
debug021:ACB3B360 DCD 1
debug021:ACB3B364 DCD 0x17
debug021:ACB3B368 DCD 3
debug021:ACB3B36C DCD 0xC9E91B66
debug021:ACB3B370 DCD 1
debug021:ACB3B374 DCD 0x17
debug021:ACB3B378 DCD 4
debug021:ACB3B37C DCD 0xC9E9182E

libsgmainso_6.4.36.so:B3EF7A7C dword_B3EF7A7C DCD 0xACB4A3A8
// tmp1_vdata?沒有用到
debug021:ACB4A3A8 DCD 0xACB31C00
debug021:ACB4A3AC DCD 0
debug021:ACB4A3B0 DCD 0x20
debug021:ACB4A3B4 DCD 0xB3EE68F9
debug021:ACB4A3B8 DCD 0xB3EE69B5
debug021:ACB4A3BC DCD 0xB3EE69F5
debug021:ACB4A3C0 DCD 0xB3EE6A81
debug021:ACB4A3C4 DCD 0xB3EE6AF1
debug021:ACB4A3C8 DCD 0

stack
BE892140  00000000
BE892144  BE892148  [stack]:BE892148
BE892148  00000000
BE89214C  B47A9038  dalvik_allocspace_allo
BE892150  0000300E
BE892154  00000000
BE892158  BE892180  [stack]:BE892180
BE89215C  B3E76771  libsgmainso_6.4.36.so:
BE892160  ACB6A718  debug021:ACB6A718



tmp1_vdata-> {datalistaddr, datalistcount, ...} datalist[0]->
data[0]{count, addr} -> tmp1_vdata -> {}





sub_9854(ACB4A3D0, 1, 0x17, 2, ...) 
sub_9854->sub_9A14‬(a, b, c, ...) // a = arg1, b = arg2, c =arg3
->sub_9d82()
datalist = tmp1_vdata->datalist;
data = datalist[0]; //datalist[i>>2]; i = 0;
int ra = tmp1_vdata->chunk_count;
if (a == ra) { // 1, data[0] == tmp1_vdata->chunk_count
	tmp1_vdata1 = data[1];
	count = tmp1_vdata1->chunk_count;
	int i = 0;
	while(i < count) { // c
		datalist1 = tmp1_vdata1->datalist;
		data1 = datalist1[i];
		int rb = data1[1]; // 9 
		if(b != rb) {
			i++;
		}
		24bitstruct 24bitstr = data1[5];
		tmp1_vdata2 = 24bitstr->vdata;
		if(tmp1_vdata2->chunk_count != 1) {
			datalist2 = tmp1_vdata2->datalist;
			int j = 0;
			while(j < datalist2->chunk_count) {
				16bitstr = datalist2[j];
				int rc = 16bitstr[3];
				if(rc == c) {
					// 這裏和棧上參數做了個對比，之前沒記錄
					// R11, [R7,#0x1C]
					// 另外對比了r10 沒記錄
					// CMP.W           R10, #0
					time = 24bitstr->time; // 0x7A005EB3
					sec = 16bitstr->sec;
					
					int xor = time ^ sec; // B3E94525 // 程序下一步的跳轉地址
					[r11] = xor; // [stack]:BE892148 DCD 0
				}
			}
		}
	}
}
LDR             R1, [R7,#0xC] //BE89216C，代表啥結構
[stack]:BE89216C DCD 0
[stack]:BE892170 DCD 0xB47A9038
[stack]:BE892174 DCD 0x2DF
[stack]:BE892178 DCD 0x75F91FF0
[stack]:BE89217C DCD 0x12DDD080
[stack]:BE892180 DCD 0x716162A0
[stack]:BE892184 DCD 0x12E51660
[stack]:BE892188 DCD 0xB4E07800
[stack]:BE89218C DCD 0xA44E7263
[stack]:BE892190 DCD 0x75F24BF8
[stack]:BE892194 DCD 0xBE892438
[stack]:BE892198 DCD 2
[stack]:BE89219C DCD 0x12C357C0

arg1 = command_arg->arg1;
跳轉到上面異或出來的地址処 // xor = time ^ sec; // B3E94525地址処，對應文件0x29524処‬
‬sub_2956C‬(command_arg, BE89216C); // 獲取傳遞參數arraylist 0xBE8921A0 -> 0x12E51660

env = command_arg->env;
jobjectarray = command_arg->args;
7E744‬ ->sub_7E784()
‬GetObjectArrayElement(env, jobjectarray);
在通過GetObjectClass獲取對應jobject，在調用GetMethodID獲取對應取元素的方法
在調用CallXXXMethod獲取數組中的value。
7E7EC‬(env, jobjectarray)->sub_7E830‬
functions->GetObjectArrayElement)()略，同上



[stack]:BE89211C DCD 1
[stack]:BE892120 DCD 1
[stack]:BE892124 DCD 0xB47A9038
[stack]:BE892128 DCD 0xB3EF7A78 // ; tmp1_data1
[stack]:BE89212C DCD 0
[stack]:BE892130 DCD 0xACB6A718 // ; command_arg


[stack]:BE89216C DCD 0
[stack]:BE892170 DCD 0xB47A9038
[stack]:BE892174 DCD 0x2DF
[stack]:BE892178 DCD 0x75F91FF0
[stack]:BE89217C DCD 0x12DDD080
[stack]:BE892180 DCD 0x716162A0
[stack]:BE892184 DCD 0x12E51660
[stack]:BE892188 DCD 0xB4E07800
[stack]:BE89218C DCD 0xA44E7263
[stack]:BE892190 DCD 0x75F24BF8
[stack]:BE892194 DCD 0xBE892438
[stack]:BE892198 DCD 2
[stack]:BE89219C DCD 0x12C357C0
29FD4‬->sub_2A01E(BE89211C, BE89216C)‬


libsgmainso-6.4.36.so B3E6B000 0008D000
------------------------------------------------------------------------------------------------------
經過這一系列的逆向發現原來sub_9B3C‬()這個函數是用來做函數地址和跳轉command處理的
最後把處理結果保存在一系列的嵌套的結構體中
這些結構體涉及上面提到的tmp1_vdata，data， 16bitstruct，24bitstruct等
核心思路是把地址和一個隨機時間異或加密，然後把地址對應的command存儲在三層的結構體中
，這樣每次保持的地址和時間值都不一樣，，後面我會酌情花時間細緻的逆向。
知道這些我們其實很容易把command和 跳轉地址記錄下來，不用走doCommandNative。

commandNative函數查找時，command 分爲三個主要參數 ：
command / 10000,
command % 10000 / 100,
command % 100
用這三個參數查找一個嵌套的結構體，找到與這三個結構體三層都一致的結構體
然後用之前記錄的時間和異或后的值再次異或就得到了跳轉地址。

